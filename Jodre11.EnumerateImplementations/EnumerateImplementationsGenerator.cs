using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Jodre11.EnumerateImplementations;

using Microsoft.CodeAnalysis;

[Generator]
public class EnumerateImplementationsGenerator : ISourceGenerator
{
    private static readonly DiagnosticDescriptor AttributedTypeIsNotPartial = new DiagnosticDescriptor(
        id: "J11EI001",
        title: $"The Attribute \'{nameof(ImplementationsAttribute)}\' can only be applied to a partial class or struct",
        messageFormat: "The attributed type was not partial",
        category: "EnumerateImplementationsGenerator",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new ImplementationsSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not ImplementationsSyntaxReceiver receiver)
        {
            return;
        }

        foreach (var attributeDefinition in receiver.AttributeDefinitions)
        {
            if (attributeDefinition.ClassDeclarationSyntax != null)
            {
                GenerateForAttributeOnClass(context, attributeDefinition);
            }

            if (attributeDefinition.StructDeclarationSyntax != null)
            {
                GenerateForAttributeOnStruct(context, attributeDefinition);
            }
        }
    }

    private void GenerateForAttributeOnClass(
        GeneratorExecutionContext context,
        AttributeDefinition definition)
    {
        if (!(definition.ClassDeclarationSyntax?.IsPartial() ?? false))
        {
            context.ReportDiagnostic(
                Diagnostic.Create(
                    AttributedTypeIsNotPartial,
                    definition.ClassDeclarationSyntax?.GetLocation() ?? Location.None));

            return;
        }

        var classDeclarationSyntax = definition.ClassDeclarationSyntax ??
                                     throw new InvalidOperationException("Internal inconsistency error!");
        
        var typeSymbol = context.Compilation
            .GetSemanticModel(classDeclarationSyntax.SyntaxTree)
            .GetDeclaredSymbol(classDeclarationSyntax);
        
        var typeName = typeSymbol?
            .ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat) ?? "EnumerateImplementations";

        var targetedTypeExpression = (TypeOfExpressionSyntax)definition.FieldArguments
            .Single()
            .Value;

        var targetedTypeSymbol = context.Compilation
            .GetSemanticModel(targetedTypeExpression.SyntaxTree)
            .GetSymbolInfo(targetedTypeExpression.Type)
            .Symbol;
        
        var definedName = definition.PropertyArguments
            .FirstOrDefault(p => p.Name == nameof(ImplementationsAttribute.MemberName))
            .Value
            ?.ToString();

        var memberName = definedName ?? $"{targetedTypeSymbol?.Name}s";
        
        var source = $$"""
                       // <auto-generated/>
                       namespace {{typeSymbol?.ContainingNamespace.ToDisplayString() ?? "Jodre11.EnumerateImplementations.Generated"}}
                       {
                           using System;
                           using {{targetedTypeSymbol?.ContainingNamespace.ToDisplayString()}};

                           public static partial class {{typeName}}
                           {
                               internal partial IEnumerable<{{targetedTypeSymbol?.Name}}> {{memberName}} => [];
                           }
                       }
                       """;

        context.AddSource($"{typeName}.g.cs", source);
    }

    private void GenerateForAttributeOnStruct(
        GeneratorExecutionContext context,
        AttributeDefinition definition)
    {
        if (definition.ClassDeclarationSyntax?.IsPartial() ?? false)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(
                    AttributedTypeIsNotPartial,
                    definition.ClassDeclarationSyntax?.GetLocation() ?? Location.None));
        }

        var mainMethod = context.Compilation.GetEntryPoint(context.CancellationToken);
        var typeName = mainMethod?.ContainingType.Name ?? "EnumerateImplementations";

        /*
        var source = $$"""
                       // <auto-generated/>
                       namespace {{mainMethod?.ContainingNamespace.ToDisplayString() ?? "Jodre11.EnumerateImplementations.Generated"}}
                       {
                           using System;

                           public static partial class {{typeName}}
                           {
                               static partial void HelloFrom(string name) =>
                               Console.WriteLine($"Generator says: Hi from '{name}'");
                           }
                       }
                       """;

        context.AddSource($"{typeName}.g.cs", source);
        */

    }
}
